import Fastify from 'fastify';
import WebSocket from 'ws';
import dotenv from 'dotenv';
import fastifyFormBody from '@fastify/formbody';
import fastifyWs from '@fastify/websocket';
import twilio from 'twilio';
import { execSync } from 'child_process';
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';

dotenv.config({ override: true });

const {
  TWILIO_ACCOUNT_SID,
  TWILIO_AUTH_TOKEN,
  PHONE_NUMBER_FROM,
  DOMAIN: rawDomain,
  OPENAI_API_KEY,
} = process.env;

// Constants
const DOMAIN = rawDomain.replace(/(^\w+:|^)\/\//, '').replace(/\/+$/, '');
const CLAWD_DIR = '/Users/henry_notabot/clawd';
const CACHE_PATH = `${CLAWD_DIR}/voice-realtime/data-cache.json`;
const CACHE_MAX_AGE_MS = 30 * 60 * 1000; // 30 minutes
const VOICE = 'alloy';

// Read cache helper â€” returns null if stale or missing
function readCache() {
  try {
    if (!existsSync(CACHE_PATH)) return null;
    const cache = JSON.parse(readFileSync(CACHE_PATH, 'utf8'));
    const age = Date.now() - new Date(cache.timestamp).getTime();
    if (age > CACHE_MAX_AGE_MS) {
      console.log(`Cache stale (${Math.round(age/60000)} min old)`);
      return null;
    }
    return cache;
  } catch (e) {
    console.log('Cache read error:', e.message);
    return null;
  }
}

// Minimal system prompt â€” rules and identity only, NO loaded files
function buildSystemMessage() {
  // Load just identity (very small)
  let identity = '';
  try {
    const idPath = `${CLAWD_DIR}/IDENTITY.md`;
    if (existsSync(idPath)) {
      identity = readFileSync(idPath, 'utf8').trim();
    }
  } catch(e) {}

  return `You are Henry III, a sharp and capable AI assistant on a phone call with Paul.
Be concise, helpful, and conversational. You have a regal but friendly vibe.
Keep responses brief â€” this is voice, not text.

${identity ? `--- YOUR IDENTITY ---\n${identity}\n\n` : ''}
--- ABOUT PAUL ---
Paul is your human. He's a retired tech leader in North Vancouver with kids Ailie and Parker.
His wife is Jen. He has back issues so reducing desk time is important.

--- CRITICAL RULES ---

1. NO DEAD AIR: You MUST speak BEFORE every tool call. Say "Let me check that" or "One moment" â€” NEVER go silent.

2. NO DUPLICATE TASKS: When Paul discusses an existing task, search first with search_tasks, then use update_task_note. Only use add_task for genuinely NEW tasks.

3. NEVER HALLUCINATE: You cannot see Telegram messages or images directly. Use get_telegram_context tool if Paul asks about recent chat. If you don't have data, say so.

4. TASK CONFIRMATION: Read back task details and get verbal "yes" before creating. EXCEPTION: If Paul says "just do it" or "put it in", submit immediately.

5. SEARCH TIP: Paul's voice may garble task names. Try short keywords. Task titles often start with "Henry:".

6. "Haley" = "Ailie" (voice dictation issue).

--- TOOLS ---
You have tools for weather, calendar, tasks, briefings, and Telegram context.
READ tools (weather, calendar, tasks_due, get_briefing, get_telegram_context) use cached data for speed.
WRITE tools (add_task, update_task_note, create_calendar_event) use live APIs.
search_tasks and get_task always use live API for accuracy.`;
}

// Tool definitions
const TOOLS = [
  {
    type: 'function',
    name: 'check_weather',
    description: 'Get current weather and forecast. Uses cached data for instant response. Includes North Vancouver, Whistler snow, and Spanish Banks wind.',
    parameters: {
      type: 'object',
      properties: {
        location: { type: 'string', description: 'Optional specific location (default uses cached North Van + Whistler)' },
      },
    },
  },
  {
    type: 'function',
    name: 'check_calendar',
    description: 'Get today and tomorrow calendar events. Uses cached data for instant response. Includes Paul, Jen, Ailie, and Parker calendars.',
    parameters: {
      type: 'object',
      properties: {
        days: { type: 'number', description: 'Number of days (ignored â€” always returns today + tomorrow from cache)' },
      },
    },
  },
  {
    type: 'function',
    name: 'tasks_due',
    description: 'List tasks due soon. Uses cached data showing top priority tasks due today/this week.',
    parameters: {
      type: 'object',
      properties: {
        range: { type: 'string', description: 'Time range (ignored â€” returns cached summary)' },
      },
    },
  },
  {
    type: 'function',
    name: 'get_briefing',
    description: 'Get full morning briefing: weather, calendar, tasks, emails, sitting time, screen time. Uses cached data for instant response.',
    parameters: {
      type: 'object',
      properties: {},
    },
  },
  {
    type: 'function',
    name: 'get_telegram_context',
    description: 'Get recent Telegram conversation between Paul and text-Henry. Use when Paul asks "what did we discuss" or references chat messages.',
    parameters: {
      type: 'object',
      properties: {
        max_messages: { type: 'number', description: 'Max messages to return (default 20)' },
      },
    },
  },
  {
    type: 'function',
    name: 'search_tasks',
    description: 'Search Toodledo tasks by keyword. Uses LIVE API for accurate real-time search.',
    parameters: {
      type: 'object',
      properties: {
        query: { type: 'string', description: 'Search term to find tasks' },
      },
      required: ['query'],
    },
  },
  {
    type: 'function',
    name: 'get_task',
    description: 'Get full details of a task by ID including notes. Uses LIVE API.',
    parameters: {
      type: 'object',
      properties: {
        task_id: { type: 'number', description: 'The Toodledo task ID' },
      },
      required: ['task_id'],
    },
  },
  {
    type: 'function',
    name: 'add_task',
    description: 'Add a new task to Toodledo. Uses LIVE API. Confirm details with Paul first unless he says "just do it".',
    parameters: {
      type: 'object',
      properties: {
        title: { type: 'string', description: 'Task title. Prefix with "Henry: " if Henry will do it.' },
        folder: { type: 'string', description: 'Folder name (default: pWorkflow)' },
        priority: { type: 'string', description: 'low, medium, or high (default: medium)' },
        duedate: { type: 'string', description: 'Due date YYYY-MM-DD format' },
        star: { type: 'boolean', description: 'Star the task' },
        note: { type: 'string', description: 'Optional note' },
      },
      required: ['title'],
    },
  },
  {
    type: 'function',
    name: 'update_task_note',
    description: 'Append a note to an EXISTING task. Uses LIVE API. Get task_id from search_tasks first.',
    parameters: {
      type: 'object',
      properties: {
        task_id: { type: 'number', description: 'The Toodledo task ID' },
        note: { type: 'string', description: 'Text to append to existing note' },
      },
      required: ['task_id', 'note'],
    },
  },
  {
    type: 'function',
    name: 'create_calendar_event',
    description: 'Create a calendar event. Uses LIVE API. Confirm details first. Family emails: jen@heth.ca, parker@heth.ca, ailie@heth.ca',
    parameters: {
      type: 'object',
      properties: {
        summary: { type: 'string', description: 'Event title' },
        start: { type: 'string', description: 'Start time YYYY-MM-DDTHH:MM:SS (24h Pacific)' },
        end: { type: 'string', description: 'End time YYYY-MM-DDTHH:MM:SS' },
        attendees: { type: 'string', description: 'Comma-separated emails to invite' },
        description: { type: 'string', description: 'Optional description' },
        location: { type: 'string', description: 'Optional location' },
      },
      required: ['summary', 'start', 'end'],
    },
  },
  {
    type: 'function',
    name: 'write_memory',
    description: 'Write to Henry\'s memory files. Uses LIVE file write.',
    parameters: {
      type: 'object',
      properties: {
        content: { type: 'string', description: 'Text to write with heading' },
        target: { type: 'string', description: '"daily" (default) or "longterm" for MEMORY.md' },
      },
      required: ['content'],
    },
  },
  {
    type: 'function',
    name: 'search_memory',
    description: 'Search Henry\'s workspace memory via QMD. Uses LIVE search.',
    parameters: {
      type: 'object',
      properties: {
        query: { type: 'string', description: 'Search query' },
      },
      required: ['query'],
    },
  },
  {
    type: 'function',
    name: 'send_message_to_clawdbot',
    description: 'Send a message to text-Henry for tasks you cannot do on call (emails, research).',
    parameters: {
      type: 'object',
      properties: {
        message: { type: 'string', description: 'The instruction to send' },
      },
      required: ['message'],
    },
  },
];

// Tool execution â€” READ tools use cache, WRITE tools use live API
async function executeTool(name, args) {
  try {
    switch (name) {
      // ===== READ TOOLS (CACHE FIRST) =====
      
      case 'check_weather': {
        const cache = readCache();
        if (cache?.voiceSummaries?.weather) {
          console.log('Weather: returning cached data');
          return cache.voiceSummaries.weather;
        }
        // Fallback to live
        console.log('Weather: cache miss, fetching live');
        const loc = args.location || 'North Vancouver';
        const result = execSync(
          `curl -s "wttr.in/${encodeURIComponent(loc)}?format=3"`,
          { timeout: 10000, encoding: 'utf8' }
        );
        return result.trim();
      }

      case 'check_calendar': {
        const cache = readCache();
        if (cache?.voiceSummaries?.calendar) {
          console.log('Calendar: returning cached data');
          const cal = cache.voiceSummaries.calendar;
          return `TODAY:\n${cal.today}\n\nTOMORROW:\n${cal.tomorrow}`;
        }
        // Fallback to live
        console.log('Calendar: cache miss, fetching live');
        const result = execSync(
          `GOG_KEYRING_PASSWORD="henrybot" gog calendar events "paul@heth.ca" --account henry@heth.ca --from today --days 2`,
          { cwd: CLAWD_DIR, timeout: 15000, encoding: 'utf8' }
        );
        return result.trim() || 'No upcoming events.';
      }

      case 'tasks_due': {
        const cache = readCache();
        if (cache?.voiceSummaries?.tasks) {
          console.log('Tasks: returning cached data');
          return cache.voiceSummaries.tasks;
        }
        // Fallback to live
        console.log('Tasks: cache miss, fetching live');
        const result = execSync(
          `node scripts/toodledo.js due week`,
          { cwd: CLAWD_DIR, timeout: 15000, encoding: 'utf8' }
        );
        return result.trim() || 'No tasks due.';
      }

      case 'get_briefing': {
        const cache = readCache();
        if (cache?.voiceSummaries) {
          console.log('Briefing: returning cached data');
          const s = cache.voiceSummaries;
          return `WEATHER:\n${s.weather}\n\nCALENDAR TODAY:\n${s.calendar?.today || 'No events'}\n\nCALENDAR TOMORROW:\n${s.calendar?.tomorrow || 'No events'}\n\nTASKS DUE:\n${s.tasks}\n\nSITTING TIME:\n${s.sitting}\n\nSCREEN TIME:\n${s.screenTime}\n\nIMPORTANT EMAILS:\n${s.emails}\n\nSCHOOL UPDATES:\n${s.schoolEmails}`;
        }
        // Fallback to live
        console.log('Briefing: cache miss, running live');
        const result = execSync(
          `node scripts/morning-briefing.js`,
          { cwd: CLAWD_DIR, timeout: 45000, encoding: 'utf8' }
        );
        return result.trim();
      }

      case 'get_telegram_context': {
        const maxMessages = args.max_messages || 20;
        try {
          // Read from today's Telegram dump file
          const today = new Date().toISOString().slice(0, 10);
          const dumpPath = `${CLAWD_DIR}/memory/telegram/${today}.md`;
          if (existsSync(dumpPath)) {
            let content = readFileSync(dumpPath, 'utf8').trim();
            // Get last N messages worth (rough estimate: 500 chars per message)
            if (content.length > maxMessages * 500) {
              content = content.slice(-(maxMessages * 500));
            }
            console.log(`Telegram: returning ${content.length} chars from dump`);
            return content || 'No Telegram messages found for today.';
          }
          // Try yesterday if today is empty
          const yesterday = new Date(Date.now() - 86400000).toISOString().slice(0, 10);
          const yesterdayPath = `${CLAWD_DIR}/memory/telegram/${yesterday}.md`;
          if (existsSync(yesterdayPath)) {
            let content = readFileSync(yesterdayPath, 'utf8').trim();
            if (content.length > maxMessages * 500) {
              content = content.slice(-(maxMessages * 500));
            }
            return `(Yesterday's messages)\n${content}`;
          }
          return 'No recent Telegram messages found.';
        } catch (e) {
          return `Error reading Telegram context: ${e.message}`;
        }
      }

      // ===== WRITE/SEARCH TOOLS (LIVE API) =====

      case 'search_tasks': {
        console.log('Search tasks: live API');
        const result = execSync(
          `node scripts/toodledo.js find "${args.query.replace(/"/g, '\\"')}"`,
          { cwd: CLAWD_DIR, timeout: 15000, encoding: 'utf8' }
        );
        const lines = result.trim().split('\n').slice(0, 10);
        return lines.join('\n') || 'No tasks found matching that search.';
      }

      case 'get_task': {
        console.log('Get task: live API');
        const taskId = args.task_id;
        const result = execSync(
          `node -e "const c = require('./scripts/toodledo_client.js'); c.apiCall('/3/tasks/get.php?f=json&id=${taskId}&fields=note,duedate,priority,folder,tag').then(d => { const t = Array.isArray(d) ? d.find(x => x.id === ${taskId}) : null; if (!t) { console.log('Task not found'); return; } const due = t.duedate ? new Date(t.duedate * 1000).toISOString().slice(0,10) : 'none'; console.log('Title: ' + t.title); console.log('Due: ' + due); console.log('Priority: ' + t.priority); console.log('Note: ' + (t.note || '(empty)')); })"`,
          { cwd: CLAWD_DIR, timeout: 15000, encoding: 'utf8' }
        );
        return result.trim() || 'Task not found.';
      }

      case 'add_task': {
        console.log('Add task: live API');
        const folder = args.folder || 'pWorkflow';
        const priority = args.priority || 'medium';
        const title = args.title;
        // Duplicate check
        try {
          const keyword = title.split(/[\s:]+/).filter(w => w.length > 3 && w.toLowerCase() !== 'henry').slice(0, 2).join(' ');
          if (keyword) {
            const existing = execSync(
              `node scripts/toodledo.js find "${keyword.replace(/"/g, '\\"')}"`,
              { cwd: CLAWD_DIR, timeout: 10000, encoding: 'utf8' }
            ).trim();
            if (existing && !existing.includes('No tasks found')) {
              return `WARNING: Similar task(s) exist:\n${existing}\n\nUse update_task_note to update existing, or confirm this is genuinely new.`;
            }
          }
        } catch(e) {}
        const noteArg = args.note ? ` --note "${args.note.replace(/"/g, '\\"')}"` : '';
        const dueArg = args.duedate ? ` --due ${args.duedate}` : '';
        const starArg = args.star ? ` --star` : '';
        const result = execSync(
          `node scripts/toodledo.js add "${title.replace(/"/g, '\\"')}" --folder "${folder}" --tag Henry --priority ${priority}${dueArg}${starArg}${noteArg}`,
          { cwd: CLAWD_DIR, timeout: 15000, encoding: 'utf8' }
        );
        return result.trim();
      }

      case 'update_task_note': {
        console.log('Update task note: live API');
        const taskId = args.task_id;
        const transcriptTs = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const transcriptRef = `\nðŸ“ž Voice call ref: memory/voice-calls/${transcriptTs}*.txt`;
        const noteWithRef = args.note + transcriptRef;
        const result = execSync(
          `node scripts/toodledo.js update-note ${taskId} --note "${noteWithRef.replace(/"/g, '\\"')}"`,
          { cwd: CLAWD_DIR, timeout: 15000, encoding: 'utf8' }
        );
        return result.trim();
      }

      case 'create_calendar_event': {
        console.log('Create calendar event: live API');
        const { summary, start, end, attendees, description, location } = args;
        let cmd = `GOG_KEYRING_PASSWORD="henrybot" gog calendar create paul@heth.ca --summary "${summary.replace(/"/g, '\\"')}" --from "${start}-08:00" --to "${end}-08:00" --send-updates all --account henry@heth.ca`;
        if (attendees) cmd += ` --attendees "${attendees}"`;
        if (description) cmd += ` --description "${description.replace(/"/g, '\\"')}"`;
        if (location) cmd += ` --location "${location.replace(/"/g, '\\"')}"`;
        const result = execSync(cmd, { cwd: CLAWD_DIR, timeout: 15000, encoding: 'utf8' });
        return result.trim() || 'Event created successfully.';
      }

      case 'write_memory': {
        console.log('Write memory: live file');
        const target = args.target || 'daily';
        const content = args.content;
        if (target === 'longterm') {
          const memPath = `${CLAWD_DIR}/MEMORY.md`;
          const existing = readFileSync(memPath, 'utf8');
          writeFileSync(memPath, existing.trimEnd() + '\n\n' + content + '\n');
          return 'Written to MEMORY.md (long-term memory).';
        } else {
          const today = new Date().toISOString().slice(0, 10);
          const dailyPath = `${CLAWD_DIR}/memory/${today}.md`;
          const timestamp = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', timeZone: 'America/Los_Angeles' });
          const entry = `\n\n## Voice Note (${timestamp})\n${content}\n`;
          if (existsSync(dailyPath)) {
            const existing = readFileSync(dailyPath, 'utf8');
            writeFileSync(dailyPath, existing + entry);
          } else {
            writeFileSync(dailyPath, `# ${today}\n${entry}`);
          }
          return `Written to today's memory file.`;
        }
      }

      case 'search_memory': {
        console.log('Search memory: live QMD');
        try {
          const result = execSync(
            `export PATH="/Users/henry_notabot/.bun/bin:$PATH" && qmd search "${args.query.replace(/"/g, '\\"')}" -n 5`,
            { timeout: 5000, encoding: 'utf8' }
          );
          return result.trim() || 'No results found.';
        } catch(e) {
          return 'Search failed.';
        }
      }

      case 'send_message_to_clawdbot': {
        console.log('Send to Clawdbot: logging');
        const timestamp = new Date().toISOString();
        const msg = `[${timestamp}] Voice call request: ${args.message}\n`;
        execSync(`echo ${JSON.stringify(msg)} >> voice-requests.log`, { cwd: CLAWD_DIR });
        return 'Message saved. Will handle it after the call.';
      }

      default:
        return `Unknown tool: ${name}`;
    }
  } catch (error) {
    console.error(`Tool ${name} error:`, error.message);
    return `Error: ${error.message?.substring(0, 100)}`;
  }
}

const PORT = process.env.PORT || 6060;

// Prevent crashes
process.on('uncaughtException', (err) => {
  console.error('Uncaught exception:', err.message);
});
process.on('unhandledRejection', (reason) => {
  console.error('Unhandled rejection:', reason);
});

const LOG_EVENT_TYPES = [
  'error',
  'response.content.done',
  'rate_limits.updated',
  'response.done',
  'input_audio_buffer.committed',
  'input_audio_buffer.speech_stopped',
  'input_audio_buffer.speech_started',
  'session.created',
  'session.updated',
  'response.function_call_arguments.done',
  'conversation.item.input_audio_transcription.completed',
  'response.audio_transcript.done',
  'response.output_audio_transcript.done'
];

if (!TWILIO_ACCOUNT_SID || !TWILIO_AUTH_TOKEN || !PHONE_NUMBER_FROM || !rawDomain || !OPENAI_API_KEY) {
  console.error('Missing environment variables. Check .env file.');
  process.exit(1);
}

const client = twilio(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN);

// Initialize Fastify
const fastify = Fastify();
fastify.register(fastifyFormBody);
fastify.register(fastifyWs);

// Root route
fastify.get('/', async (request, reply) => {
  reply.send({ message: 'Henry III Voice Server (cache-enabled) running!' });
});

// Active call tracking
let activeCall = null;
let latestCallerNumber = 'unknown';

// Safety: auto-release stale calls after 30 minutes
function releaseStaleCall() {
  if (activeCall && (Date.now() - activeCall.startTime.getTime() > 30 * 60 * 1000)) {
    console.log(`STALE CALL: Auto-releasing after 30min`);
    activeCall = null;
  }
}
setInterval(releaseStaleCall, 60 * 1000);

// Twilio incoming call webhook
fastify.all('/incoming-call', async (request, reply) => {
  const callerNumber = request.body?.From || request.query?.From || 'unknown';
  latestCallerNumber = callerNumber;
  console.log(`Incoming call from: ${callerNumber}`);

  if (activeCall) {
    console.log(`BUSY: Rejecting call â€” active call in progress`);
    const busyTwiml = `<?xml version="1.0" encoding="UTF-8"?>
      <Response>
        <Say>Sorry, Henry is on another call. Try again in a few minutes.</Say>
        <Hangup/>
      </Response>`;
    reply.type('text/xml').send(busyTwiml);
    return;
  }

  activeCall = { callerNumber, startTime: new Date() };
  console.log(`Call accepted from: ${callerNumber}`);

  const twimlResponse = `<?xml version="1.0" encoding="UTF-8"?>
    <Response>
      <Say>Connecting you to Henry.</Say>
      <Connect>
        <Stream url="wss://${DOMAIN}/media-stream">
          <Parameter name="callerNumber" value="${callerNumber}" />
        </Stream>
      </Connect>
    </Response>`;
  reply.type('text/xml').send(twimlResponse);
});

// WebSocket route for media-stream
fastify.register(async (fastify) => {
  fastify.get('/media-stream', { websocket: true }, (connection, req) => {
    console.log('Client connected to media stream');

    const transcript = [];
    const callStartTime = new Date();

    const openAiWs = new WebSocket('wss://api.openai.com/v1/realtime?model=gpt-realtime', {
      headers: {
        Authorization: `Bearer ${OPENAI_API_KEY}`,
      },
    });

    let streamSid = null;

    const sendSessionUpdate = async () => {
      const systemMessage = buildSystemMessage();
      console.log(`System prompt: ${systemMessage.length} chars (minimal, cache-enabled)`);
      
      const sessionUpdate = {
        type: 'session.update',
        session: {
          type: 'realtime',
          model: 'gpt-realtime',
          output_modalities: ['audio'],
          audio: {
            input: {
              format: { type: 'audio/pcmu' },
              transcription: { model: 'gpt-4o-mini-transcribe' },
              turn_detection: {
                type: 'server_vad',
                threshold: 0.75,
                prefix_padding_ms: 300,
                silence_duration_ms: 900,
              },
            },
            output: {
              format: { type: 'audio/pcmu' },
              voice: VOICE,
            },
          },
          instructions: systemMessage,
          tools: TOOLS,
          tool_choice: 'auto',
        },
      };

      // Caller verification
      const PAUL_NUMBER = process.env.PAUL_PHONE || '+16045551234';
      const safeWord = process.env.SAFE_WORD || '';
      const callerInfo = connection.callerNumber || latestCallerNumber || 'unknown';
      const isKnownCaller = callerInfo === PAUL_NUMBER && callerInfo !== 'unknown';
      
      if (!isKnownCaller) {
        // LOCKDOWN for unknown callers
        sessionUpdate.session.instructions = `You are Henry III. This call is from an UNVERIFIED caller (${callerInfo}).

SECURITY: Ask for safe word before proceeding. The safe word is: "${safeWord}" â€” caller must say it first.
Until verified: share ZERO personal info, don't confirm/deny anything, keep responses short.
If they provide correct safe word, say "Identity verified, welcome!" and proceed normally.`;
        delete sessionUpdate.session.tools;
        delete sessionUpdate.session.tool_choice;
      }

      console.log('Sending session update');
      openAiWs.send(JSON.stringify(sessionUpdate));

      // Initial greeting
      const greet = isKnownCaller 
        ? 'Greet Paul with just: "Paul!"'
        : 'Say: "Hello, this is Henry. Please provide the safe word to continue."';
      openAiWs.send(JSON.stringify({
        type: 'conversation.item.create',
        item: {
          type: 'message',
          role: 'user',
          content: [{ type: 'input_text', text: greet }],
        },
      }));
      openAiWs.send(JSON.stringify({ type: 'response.create' }));
    };

    let isAiSpeaking = false;
    let audioChunksSent = 0;

    openAiWs.on('open', () => {
      console.log('Connected to OpenAI Realtime API');
      setTimeout(sendSessionUpdate, 100);
    });

    openAiWs.on('message', async (data) => {
      try {
        const response = JSON.parse(data);

        if (LOG_EVENT_TYPES.includes(response.type)) {
          console.log(`OpenAI: ${response.type}`);
        }

        // Audio to Twilio
        if ((response.type === 'response.audio.delta' || response.type === 'response.output_audio.delta') && response.delta) {
          isAiSpeaking = true;
          audioChunksSent++;
          if (connection.readyState === 1) {
            connection.send(JSON.stringify({
              event: 'media',
              streamSid: streamSid,
              media: { payload: response.delta },
            }));
          }
        }

        if (response.type === 'response.done') {
          isAiSpeaking = false;
          audioChunksSent = 0;
        }

        // Barge-in handling
        if (response.type === 'input_audio_buffer.speech_started') {
          if (connection.readyState === 1) {
            connection.send(JSON.stringify({ event: 'clear', streamSid }));
          }
          if (isAiSpeaking) {
            openAiWs.send(JSON.stringify({ type: 'response.cancel' }));
            isAiSpeaking = false;
          }
        }

        // Transcript collection
        if (response.type === 'conversation.item.input_audio_transcription.completed') {
          console.log(`ðŸ“ž CALLER: ${response.transcript}`);
          if (response.transcript) transcript.push(`[CALLER] ${response.transcript}`);
        }
        if (response.type === 'response.audio_transcript.done' || response.type === 'response.output_audio_transcript.done') {
          console.log(`ðŸ¤– HENRY: ${response.transcript}`);
          if (response.transcript) transcript.push(`[HENRY] ${response.transcript}`);
        }

        // Tool calls
        if (response.type === 'response.function_call_arguments.done') {
          console.log(`Tool: ${response.name}(${response.arguments})`);
          try {
            const args = JSON.parse(response.arguments);
            const result = await executeTool(response.name, args);
            console.log(`Result: ${result.substring(0, 200)}`);

            openAiWs.send(JSON.stringify({
              type: 'conversation.item.create',
              item: {
                type: 'function_call_output',
                call_id: response.call_id,
                output: result,
              },
            }));
            openAiWs.send(JSON.stringify({ type: 'response.create' }));
          } catch (error) {
            console.error(`Tool error:`, error.message);
            openAiWs.send(JSON.stringify({
              type: 'conversation.item.create',
              item: {
                type: 'function_call_output',
                call_id: response.call_id,
                output: `Error: ${error.message}`,
              },
            }));
            openAiWs.send(JSON.stringify({ type: 'response.create' }));
          }
        }

        if (response.type === 'error') {
          console.error('OpenAI ERROR:', JSON.stringify(response, null, 2));
        }
      } catch (error) {
        console.error('Error processing message:', error);
      }
    });

    openAiWs.on('close', (code, reason) => {
      console.log(`OpenAI disconnected (code: ${code})`);
    });

    openAiWs.on('error', (error) => {
      console.error('OpenAI error:', error.message);
    });

    // Twilio events
    connection.on('message', (message) => {
      try {
        const data = JSON.parse(message);
        switch (data.event) {
          case 'media':
            if (openAiWs.readyState === WebSocket.OPEN) {
              openAiWs.send(JSON.stringify({
                type: 'input_audio_buffer.append',
                audio: data.media.payload,
              }));
            }
            break;
          case 'start':
            streamSid = data.start.streamSid;
            connection.callerNumber = data.start.customParameters?.callerNumber || 'unknown';
            console.log(`Stream started: ${streamSid}`);
            break;
          case 'stop':
            console.log('Stream stopped');
            if (openAiWs.readyState === WebSocket.OPEN) openAiWs.close();
            break;
        }
      } catch (error) {
        console.error('Twilio message error:', error);
      }
    });

    connection.on('close', () => {
      try {
        if (openAiWs.readyState === WebSocket.OPEN) openAiWs.close();
      } catch (e) {}
      console.log('Client disconnected');
      activeCall = null;

      // Save transcript
      if (transcript.length > 0) {
        try {
          const ts = callStartTime.toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const transcriptDir = `${CLAWD_DIR}/memory/voice-calls`;
          if (!existsSync(transcriptDir)) mkdirSync(transcriptDir, { recursive: true });
          const transcriptFile = `${transcriptDir}/${ts}.txt`;
          writeFileSync(transcriptFile, transcript.join('\n'));
          console.log(`Transcript saved: ${transcriptFile}`);

          // Async summarization
          import('child_process').then(cp => {
            cp.exec(
              `node scripts/summarize-call.js "${transcriptFile}"`,
              { cwd: CLAWD_DIR, timeout: 60000 },
              (err, stdout) => {
                if (stdout) console.log('Summary:', stdout.trim());
              }
            );
          });
        } catch (e) {
          console.error('Transcript save error:', e.message);
        }
      }
    });

    connection.on('error', (error) => {
      console.error('Twilio error:', error.message);
    });
  });
});

// Outbound call endpoint
fastify.post('/make-call', async (request, reply) => {
  const { to } = request.body || {};
  if (!to) return reply.code(400).send({ error: 'Missing "to" phone number' });

  try {
    const twiml = `<?xml version="1.0" encoding="UTF-8"?><Response><Connect><Stream url="wss://${DOMAIN}/media-stream" /></Connect></Response>`;
    const call = await client.calls.create({
      from: PHONE_NUMBER_FROM,
      to,
      twiml,
    });
    console.log(`Outbound call: ${call.sid}`);
    reply.send({ success: true, callSid: call.sid });
  } catch (error) {
    console.error('Call error:', error);
    reply.code(500).send({ error: error.message });
  }
});

// Start server
fastify.listen({ port: PORT, host: '0.0.0.0' }, (err) => {
  if (err) {
    console.error(err);
    process.exit(1);
  }
  console.log(`Henry III Voice Server (cache-enabled) on port ${PORT}`);
  console.log(`WebSocket: wss://${DOMAIN}/media-stream`);
});
